## Overview
The visualization worker orchestrates a long-running asyncio process that fetches vectors from Qdrant, runs UMAP/HDBSCAN, and writes HTML results to S3. It has solid observability, but heavy synchronous work blocks the event loop and S3 uploads bypass async safety.

## High
- **Blocking AWS SDK calls inside async coroutines** – `S3Storage.upload_visualization`, `generate_presigned_url`, and `delete_visualization` call boto3’s synchronous client directly from `await`-ed functions. See [crates/worker-visualizations-py/src/storage.py#L59-L129](crates/worker-visualizations-py/src/storage.py#L59-L129) and [crates/worker-visualizations-py/src/storage.py#L130-L225](crates/worker-visualizations-py/src/storage.py#L130-L225). These operations hold the event loop while the SDK performs blocking I/O. Offload them with `asyncio.to_thread` (or switch to aiobotocore) to keep progress updates responsive.
- **Qdrant access and ML steps run synchronously on the event loop** – `_fetch_vectors_from_qdrant`, `_apply_umap`, and `_apply_hdbscan` call synchronous libraries (qdrant-client, UMAP, HDBSCAN) but are marked `async`. See [crates/worker-visualizations-py/src/processor.py#L173-L265](crates/worker-visualizations-py/src/processor.py#L173-L265), [crates/worker-visualizations-py/src/processor.py#L268-L308](crates/worker-visualizations-py/src/processor.py#L268-L308), and [crates/worker-visualizations-py/src/processor.py#L309-L372](crates/worker-visualizations-py/src/processor.py#L309-L372). These CPU-heavy sections block every other coroutine; run them in a thread/process pool or make the pipeline fully synchronous.

## Medium
- **Visualization processor re-creates a Qdrant client per job** – `process_visualization_job` constructs `VisualizationProcessor` with every invocation, which in turn instantiates a gRPC client. Cache the processor per connection to avoid repeated TLS handshakes. See [crates/worker-visualizations-py/src/processor.py#L35-L47](crates/worker-visualizations-py/src/processor.py#L35-L47) and the call site in [crates/worker-visualizations-py/src/main.py#L309-L329](crates/worker-visualizations-py/src/main.py#L309-L329).
- **Health/readiness never reflect stalled jobs** – The worker only updates `health_state` when a job finishes. If a blocking call wedges the loop, probes continue returning 200. Add watchdog timers or expose last progress via metrics (see [crates/worker-visualizations-py/src/main.py#L150-L175](crates/worker-visualizations-py/src/main.py#L150-L175)).

## Low
- **Retry strategy on failed publishes is single-shot** – When publishing status/result messages fails, the worker logs and continues (sometimes nacking to retry). Consider exponential backoff with a bounded number of attempts so transient NATS outages don’t immediately escalate to job failures.
