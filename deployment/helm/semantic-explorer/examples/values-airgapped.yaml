# Air-Gapped RKE2 Production Environment
# This values file is designed for air-gapped Kubernetes RKE2 deployments with:
# - NO ROOT containers (all containers run as non-root)
# - NO CRDs (ServiceMonitors disabled)
# - NO RBAC (ClusterRoles, Roles, RoleBindings disabled)
# - NO Operators required
# - External infrastructure (PostgreSQL, NATS, Qdrant, S3 provided externally)
#
# Prerequisites:
# 1. Push all required images to your internal registry
# 2. Create required secrets for external services
# 3. Ensure storage class exists in your cluster
#
# Use with: helm install semantic-explorer . -f examples/values-airgapped-rke2.yaml

global:
  # IMPORTANT: Set this to your internal/private registry
  imageRegistry: "registry.internal.example.com"
  imagePullSecrets:
    - name: registry-credentials
  storageClass: "local-path"  # Change to your RKE2 storage class
  environment: production
  # Secure init container (non-root)
  initContainer:
    image: "library/busybox:1.36"  # Ensure this is in your internal registry
  securityContext:
    runAsNonRoot: true
    runAsUser: 10001
    runAsGroup: 10001
    fsGroup: 10001
    fsGroupChangePolicy: "OnRootMismatch"
    seccompProfile:
      type: RuntimeDefault
  podSecurityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL
    readOnlyRootFilesystem: true
  networkPolicy:
    enabled: true
  serviceMesh:
    enabled: false

# API Service - Production
api:
  enabled: true
  replicaCount: 3
  image:
    repository: jofish89/semantic-explorer
    tag: "latest"
    pullPolicy: IfNotPresent  # Use IfNotPresent for air-gapped
  resources:
    requests:
      cpu: 1000m
      memory: 1Gi
    limits:
      cpu: 4000m
      memory: 4Gi
  autoscaling:
    enabled: false  # HPA requires metrics-server, disable if not available
  podDisruptionBudget:
    enabled: true
    minAvailable: 1
  serviceAccount:
    create: true
    annotations: {}
    name: "sa-semantic-explorer-api"
  # DISABLE ServiceMonitor (requires Prometheus Operator CRD)
  metrics:
    enabled: true
    serviceMonitor:
      enabled: false  # DISABLED - requires ServiceMonitor CRD
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchExpressions:
                - key: app.kubernetes.io/name
                  operator: In
                  values:
                    - api
            topologyKey: kubernetes.io/hostname

# Worker Collections - Production
workerCollections:
  enabled: true
  replicaCount: 3
  image:
    repository: jofish89/worker-collections
    tag: "latest"
    pullPolicy: IfNotPresent
  resources:
    requests:
      cpu: 1000m
      memory: 1Gi
    limits:
      cpu: 4000m
      memory: 2Gi
  autoscaling:
    enabled: false
  podDisruptionBudget:
    enabled: true
    minAvailable: 1
  serviceAccount:
    create: true
    annotations: {}
    name: "sa-semantic-explorer-worker-collections"
  # DISABLE ServiceMonitor
  metrics:
    enabled: true
    serviceMonitor:
      enabled: false  # DISABLED - requires ServiceMonitor CRD

# Worker Datasets - Production
workerDatasets:
  enabled: true
  replicaCount: 3
  image:
    repository: jofish89/worker-datasets
    tag: "latest"
    pullPolicy: IfNotPresent
  resources:
    requests:
      cpu: 1000m
      memory: 2Gi
    limits:
      cpu: 4000m
      memory: 8Gi
  autoscaling:
    enabled: false
  podDisruptionBudget:
    enabled: true
    minAvailable: 1
  serviceAccount:
    create: true
    annotations: {}
    name: "sa-semantic-explorer-worker-datasets"
  # DISABLE ServiceMonitor
  metrics:
    enabled: true
    serviceMonitor:
      enabled: false  # DISABLED - requires ServiceMonitor CRD

# Worker Visualizations - Production
workerVisualizationsPy:
  enabled: true
  replicaCount: 2
  image:
    repository: jofish89/worker-visualizations-py
    tag: "latest"
    pullPolicy: IfNotPresent
  resources:
    requests:
      cpu: 1000m
      memory: 8Gi
    limits:
      cpu: 4000m
      memory: 16Gi
  autoscaling:
    enabled: false
  podDisruptionBudget:
    enabled: true
    minAvailable: 1
  serviceAccount:
    create: true
    annotations: {}
    name: "sa-semantic-explorer-worker-visualizations-py"
  # No ServiceMonitor for this worker (metrics not exposed by default)
  metrics:
    enabled: false

# ============================================================================
# EXTERNAL INFRASTRUCTURE - All subcharts DISABLED
# ============================================================================

# PostgreSQL - DISABLED (use external)
postgresql:
  enabled: false
  external:
    enabled: true
    host: "postgres.internal.example.com"
    port: 5432
    database: semantic_explorer
    username: semantic_explorer
    existingSecret: "postgresql-secret"
    passwordKey: "password"
    sslMode: require

# Redis - DISABLED (use external)
redis:
  enabled: false
  external:
    enabled: true
    clusterNodes: "redis://redis.internal.example.com:6379"
    existingSecret: "redis-secret"
    passwordKey: "password"

# NATS - DISABLED (use external)
nats:
  enabled: false
  external:
    enabled: true
    url: "nats://nats.internal.example.com:4222"

# Qdrant - DISABLED (use external)
qdrant:
  enabled: false
  external:
    enabled: true
    url: "http://qdrant.internal.example.com:6334"
    existingSecret: "qdrant-secret"
    apiKeyKey: "api-key"

# MinIO - DISABLED (use external S3-compatible storage)
minio:
  enabled: false

# Storage Configuration (S3-compatible)
storage:
  s3:
    endpoint: "http://s3.internal.example.com:9000"
    region: "us-east-1"
    bucketName: "semantic-explorer-files"
    existingSecret: "s3-secret"
    accessKeyIdKey: "access-key-id"
    secretAccessKeyKey: "secret-access-key"

# Encryption Configuration
encryption:
  # REQUIRED: Set a proper master key for production
  # Generate with: openssl rand -hex 32
  masterKey: ""  # Set via existingSecret or value

# Dex - OIDC Provider (optional, can use external)
dex:
  enabled: false  # Disable if using external OIDC provider
  external:
    enabled: true
    issuerUrl: "https://oidc.internal.example.com"
    existingSecret: "oidc-secret"
    clientIdKey: "client-id"
    clientSecretKey: "client-secret"

# ============================================================================
# OBSERVABILITY - Minimal setup without CRDs/RBAC
# ============================================================================

observability:
  # OpenTelemetry Collector - enabled for metrics/tracing aggregation
  otelCollector:
    enabled: true
    image:
      repository: otel/opentelemetry-collector-contrib
      tag: "0.92.0"  # Pin specific version for air-gapped
      pullPolicy: IfNotPresent
    resources:
      requests:
        cpu: 200m
        memory: 256Mi
      limits:
        cpu: 1000m
        memory: 1Gi
    # Non-root security context
    podSecurityContext:
      runAsNonRoot: true
      runAsUser: 10001
      fsGroup: 10001
      fsGroupChangePolicy: "OnRootMismatch"
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
          - ALL
      readOnlyRootFilesystem: true
    config:
      extensions:
        health_check:
          endpoint: 0.0.0.0:13133
      receivers:
        otlp:
          protocols:
            grpc:
              endpoint: 0.0.0.0:4317
              max_recv_msg_size_mib: 100
            http:
              endpoint: 0.0.0.0:4318
      processors:
        batch:
          timeout: 10s
          send_batch_size: 1024
        memory_limiter:
          check_interval: 1s
          limit_mib: 512
          spike_limit_mib: 128
      exporters:
        prometheus:
          endpoint: "0.0.0.0:8889"
        logging:
          verbosity: normal
          sampling_initial: 5
          sampling_thereafter: 200
      service:
        extensions: [health_check]
        pipelines:
          metrics:
            receivers: [otlp]
            processors: [memory_limiter, batch]
            exporters: [prometheus, logging]
          traces:
            receivers: [otlp]
            processors: [memory_limiter, batch]
            exporters: [logging]
          logs:
            receivers: [otlp]
            processors: [memory_limiter, batch]
            exporters: [logging]

  # Prometheus - DISABLED (use external or different monitoring)
  prometheus:
    enabled: false
    external:
      enabled: true
      url: "http://prometheus.internal.example.com:9090"

  # Quickwit - DISABLED (use external log aggregation)
  quickwit:
    enabled: false
    external:
      enabled: true
      url: "http://quickwit.internal.example.com:7280"

# ============================================================================
# SUBCHARTS - ALL DISABLED to avoid RBAC/CRD/Operator requirements
# ============================================================================

# Prometheus subchart - DISABLED (creates ClusterRole/ClusterRoleBinding)
prometheus:
  enabled: false

# Grafana subchart - DISABLED (creates ClusterRole/Role/RoleBindings, runs root init container)
grafana:
  enabled: false
  external:
    enabled: true
    url: "http://grafana.internal.example.com:3000"

# Network Policy - enabled for security
networkPolicy:
  enabled: true
  ingress:
    fromIngress: true
    fromNamespaces: []
    fromPods: []
  egress:
    toDns: true
    toInternet: false  # Disable for air-gapped
    toNamespaces: []
    toCidr:
      - 10.0.0.0/8      # Allow internal network
      - 172.16.0.0/12   # Allow internal network
      - 192.168.0.0/16  # Allow internal network

# Common labels and annotations
commonLabels:
  environment: production
  deployment-type: airgapped

commonAnnotations: {}

# ============================================================================
# REQUIRED SECRETS - Create before deployment
# ============================================================================
#
# kubectl create secret generic postgresql-secret \
#   --from-literal=password="your-postgres-password"
#
# kubectl create secret generic redis-secret \
#   --from-literal=password="your-redis-password"
#
# kubectl create secret generic qdrant-secret \
#   --from-literal=api-key="your-qdrant-api-key"
#
# kubectl create secret generic s3-secret \
#   --from-literal=access-key-id="your-access-key" \
#   --from-literal=secret-access-key="your-secret-key"
#
# kubectl create secret generic oidc-secret \
#   --from-literal=client-id="your-client-id" \
#   --from-literal=client-secret="your-client-secret"
#
# kubectl create secret generic registry-credentials \
#   --type=kubernetes.io/dockerconfigjson \
#   --from-file=.dockerconfigjson=/path/to/config.json
#
# ============================================================================

# ============================================================================
# REQUIRED IMAGES - Push to internal registry before deployment
# ============================================================================
#
# Core application images:
#   - jofish89/semantic-explorer:latest
#   - jofish89/worker-collections:latest
#   - jofish89/worker-datasets:latest
#   - jofish89/worker-visualizations-py:latest
#
# Infrastructure images:
#   - library/busybox:1.36 (init containers)
#   - otel/opentelemetry-collector-contrib:0.92.0
#
# Example mirroring commands:
#   skopeo copy docker://docker.io/jofish89/semantic-explorer:latest \
#     docker://registry.internal.example.com/jofish89/semantic-explorer:latest
#
# ============================================================================
